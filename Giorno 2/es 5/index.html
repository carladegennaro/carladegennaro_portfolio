<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refined Detail Face</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #05000a; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.11/lib/p5.min.js"></script>
    <script>
        let faccione;
        let gap = 1.1; // Leggermente aumentato per distanziare le linee

        function preload() {
            faccione = loadImage('IMG_4119.png');
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            // Risoluzione alta per il dettaglio, ma gap stretto per dimensioni ridotte
            faccione.resize(400, 0); 
            faccione.loadPixels();
        }

        function draw() {
            background(0); 
            
            let numH = faccione.width;
            let numV = faccione.height;
            
            let ox = (width - (numH * gap)) / 2;
            let oy = (height - (numV * gap)) / 2;

            let centerX = width / 2;
            let centerY = height / 2;
            let mouseD = dist(mouseX, mouseY, centerX, centerY);
            
            // IntensitÃ  con zona morta centrale
            let intensity = 0;
            if (mouseD > 25) {
                intensity = map(mouseD, 25, width/2, 0, 3, true);
            }

            let t = frameCount * 0.2;

            // CAMPIONAMENTO BILANCIATO
            // i += 2 crea meno puntini orizzontalmente, evidenziando le linee verticali
            for (let i = 0; i < numH; i += 2) { 
                for (let j = 0; j < numV; j += 3) { // Salto verticale per definire i singoli punti
                    
                    let index = (i + j * faccione.width) * 4;
                    let r = faccione.pixels[index];
                    let g = faccione.pixels[index + 1];
                    let b = faccione.pixels[index + 2];
                    let al = faccione.pixels[index + 3];
                    let br = (r + g + b) / 3;

                    if (al < 50 || br < 15) continue;

                    // Movimento reattivo e fluido
                    let wave = sin(j * 0.15 + t) * (intensity * 15) * (br / 255);
                    let jitter = (noise(i * 0.1, t) - 0.5) * (intensity * 20);

                    let px = ox + i * gap + wave + jitter;
                    let py = oy + j * gap;

                    // Puntini definiti
                    let size = map(br, 0, 255, 0.8, 3.5);
                    strokeWeight(size);
                    stroke(255, 20, 147, map(br, 0, 255, 120, 255));
                    
                    point(px, py);
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>